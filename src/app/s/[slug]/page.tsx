import { Metadata } from 'next';
import { createServerClient } from '@/lib/supabase';
import { notFound } from 'next/navigation';

export const runtime = 'edge';

interface PageProps {
    params: Promise<{ slug: string }>;
}

// Generate metadata for SEO
export async function generateMetadata({ params }: PageProps): Promise<Metadata> {
    const { slug } = await params;
    const supabase = createServerClient();

    const { data: site } = await supabase
        .from('sites')
        .select('title, description')
        .eq('slug', slug)
        .eq('published', true)
        .single();

    if (!site) {
        return { title: 'Site Not Found' };
    }

    return {
        title: site.title,
        description: site.description || `${site.title} - Built with Lulo`,
    };
}

export default async function PublicSitePage({ params }: PageProps) {
    const { slug } = await params;
    const supabase = createServerClient();

    // Fetch the published site
    const { data: site, error } = await supabase
        .from('sites')
        .select('*')
        .eq('slug', slug)
        .eq('published', true)
        .single();

    if (error || !site) {
        notFound();
    }

    // Increment view count (fire and forget)
    supabase
        .from('sites')
        .update({ view_count: (site.view_count || 0) + 1 })
        .eq('id', site.id)
        .then(() => { });

    // Return the HTML content directly
    // We use dangerouslySetInnerHTML but the content is generated by AI, not user input
    return (
        <html>
            <head>
                <meta charSet="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1" />
                <title>{site.title}</title>
                <meta name="description" content={site.description || ''} />
                <link rel="preconnect" href="https://fonts.googleapis.com" />
                <link rel="preconnect" href="https://fonts.gstatic.com" crossOrigin="anonymous" />
                <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet" />
                <style dangerouslySetInnerHTML={{ __html: site.css_content || '' }} />
            </head>
            <body dangerouslySetInnerHTML={{ __html: extractBody(site.html_content || '') }} />
        </html>
    );
}

// Extract body content from full HTML
function extractBody(html: string): string {
    // Try to extract just the body content
    const bodyMatch = html.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
    if (bodyMatch) {
        return bodyMatch[1];
    }

    // If no body tag, check if it's a full HTML doc and extract after head
    if (html.includes('<!DOCTYPE') || html.includes('<html')) {
        // Try to extract everything after </head>
        const afterHead = html.split(/<\/head>/i)[1];
        if (afterHead) {
            // Remove closing body/html tags and return
            return afterHead.replace(/<\/?(body|html)[^>]*>/gi, '');
        }
    }

    // Return as-is if we can't parse it
    return html;
}
